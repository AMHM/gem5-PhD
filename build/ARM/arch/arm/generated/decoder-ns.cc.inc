// DO NOT EDIT
// This file was automatically generated from an ISA description:
//   arm/isa/main.isa

#if !defined(__SPLIT) || (__SPLIT == 1)

    Movz::Movz(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegImmImmOp("movz", machInst, IntAluOp,
                         _dest, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Movk::Movk(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegImmImmOp("movk", machInst, IntAluOp,
                         _dest, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = dest;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Movn::Movn(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegImmImmOp("movn", machInst, IntAluOp,
                         _dest, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc::LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 1) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UN_WY_SZ4::LOAD_IMM_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 1) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc::LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UN_WY_SZ4::LOAD_REG_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc::LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UN_WY_SZ4::LOAD_IMM_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc::LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UN_WY_SZ4::LOAD_REG_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc::LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UN_WY_SZ4::LOAD_IMM_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc::LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UN_WY_SZ4::LOAD_REG_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc::LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UN_WY_SZ4::LOAD_IMM_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc::LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UN_WY_SZ4::LOAD_REG_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UN_WN_SZ4::LOAD_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UN_WN_SZ4::LOAD_REG_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UN_WN_SZ4::LOAD_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UN_WN_SZ4::LOAD_REG_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc::LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UY_WY_SZ4::LOAD_IMM_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc::LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UY_WY_SZ4::LOAD_REG_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc::LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UY_WY_SZ4::LOAD_IMM_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc::LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UY_WY_SZ4::LOAD_REG_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc::LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UY_WY_SZ4::LOAD_IMM_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc::LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UY_WY_SZ4::LOAD_REG_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc::LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UY_WY_SZ4::LOAD_IMM_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc::LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UY_WY_SZ4::LOAD_REG_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UY_WN_SZ4::LOAD_IMM_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UY_WN_SZ4::LOAD_REG_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UY_WN_SZ4::LOAD_IMM_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UY_WN_SZ4::LOAD_REG_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc::LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UN_WY_SZ1::LOAD_IMM_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc::LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UN_WY_SZ1::LOAD_REG_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc::LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UN_WY_SZ1::LOAD_IMM_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc::LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UN_WY_SZ1::LOAD_REG_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc::LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UN_WY_SZ1::LOAD_IMM_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc::LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UN_WY_SZ1::LOAD_REG_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc::LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UN_WY_SZ1::LOAD_IMM_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc::LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UN_WY_SZ1::LOAD_REG_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UN_WN_SZ1::LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UN_WN_SZ1::LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UN_WN_SZ1::LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UN_WN_SZ1::LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc::LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UY_WY_SZ1::LOAD_IMM_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc::LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UY_WY_SZ1::LOAD_REG_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc::LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UY_WY_SZ1::LOAD_IMM_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc::LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UY_WY_SZ1::LOAD_REG_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc::LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UY_WY_SZ1::LOAD_IMM_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc::LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UY_WY_SZ1::LOAD_REG_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc::LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UY_WY_SZ1::LOAD_IMM_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc::LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UY_WY_SZ1::LOAD_REG_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UY_WN_SZ1::LOAD_IMM_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UY_WN_SZ1::LOAD_REG_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UY_WN_SZ1::LOAD_IMM_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UY_WN_SZ1::LOAD_REG_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc::LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SY_UN_WY_SZ1::LOAD_IMM_AY_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc::LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SY_UN_WY_SZ1::LOAD_REG_AY_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc::LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SY_UN_WY_SZ1::LOAD_IMM_AN_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc::LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SY_UN_WY_SZ1::LOAD_REG_AN_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc::LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UN_WY_SZ1::LOAD_IMM_AY_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc::LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UN_WY_SZ1::LOAD_REG_AY_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc::LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UN_WY_SZ1::LOAD_IMM_AN_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc::LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UN_WY_SZ1::LOAD_REG_AN_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UN_WN_SZ1::LOAD_IMM_AY_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UN_WN_SZ1::LOAD_REG_AY_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UN_WN_SZ1::LOAD_IMM_AN_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UN_WN_SZ1::LOAD_REG_AN_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc::LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SY_UY_WY_SZ1::LOAD_IMM_AY_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc::LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SY_UY_WY_SZ1::LOAD_REG_AY_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc::LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SY_UY_WY_SZ1::LOAD_IMM_AN_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc::LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SY_UY_WY_SZ1::LOAD_REG_AN_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc::LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UY_WY_SZ1::LOAD_IMM_AY_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc::LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UY_WY_SZ1::LOAD_REG_AY_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc::LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UY_WY_SZ1::LOAD_IMM_AN_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc::LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UY_WY_SZ1::LOAD_REG_AN_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UY_WN_SZ1::LOAD_IMM_AY_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UY_WN_SZ1::LOAD_REG_AY_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UY_WN_SZ1::LOAD_IMM_AN_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UY_WN_SZ1::LOAD_REG_AN_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc::LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UN_WY_SZ2::LOAD_IMM_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc::LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UN_WY_SZ2::LOAD_REG_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc::LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UN_WY_SZ2::LOAD_IMM_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc::LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UN_WY_SZ2::LOAD_REG_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc::LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UN_WY_SZ2::LOAD_IMM_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc::LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UN_WY_SZ2::LOAD_REG_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc::LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UN_WY_SZ2::LOAD_IMM_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc::LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UN_WY_SZ2::LOAD_REG_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UN_WN_SZ2::LOAD_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UN_WN_SZ2::LOAD_REG_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UN_WN_SZ2::LOAD_IMM_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UN_WN_SZ2::LOAD_REG_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc::LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SN_UY_WY_SZ2::LOAD_IMM_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc::LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SN_UY_WY_SZ2::LOAD_REG_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc::LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SN_UY_WY_SZ2::LOAD_IMM_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc::LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SN_UY_WY_SZ2::LOAD_REG_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc::LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UY_WY_SZ2::LOAD_IMM_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc::LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UY_WY_SZ2::LOAD_REG_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc::LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UY_WY_SZ2::LOAD_IMM_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc::LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UY_WY_SZ2::LOAD_REG_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SN_UY_WN_SZ2::LOAD_IMM_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SN_UY_WN_SZ2::LOAD_REG_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SN_UY_WN_SZ2::LOAD_IMM_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SN_UY_WN_SZ2::LOAD_REG_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc::LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SY_UN_WY_SZ2::LOAD_IMM_AY_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc::LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SY_UN_WY_SZ2::LOAD_REG_AY_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc::LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SY_UN_WY_SZ2::LOAD_IMM_AN_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc::LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SY_UN_WY_SZ2::LOAD_REG_AN_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc::LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UN_WY_SZ2::LOAD_IMM_AY_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc::LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UN_WY_SZ2::LOAD_REG_AY_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc::LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UN_WY_SZ2::LOAD_IMM_AN_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc::LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UN_WY_SZ2::LOAD_REG_AN_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UN_WN_SZ2::LOAD_IMM_AY_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UN_WN_SZ2::LOAD_REG_AY_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UN_WN_SZ2::LOAD_IMM_AN_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UN_WN_SZ2::LOAD_REG_AN_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc::LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PY_SY_UY_WY_SZ2::LOAD_IMM_AY_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc::LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PY_SY_UY_WY_SZ2::LOAD_REG_AY_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc::LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PY_SY_UY_WY_SZ2::LOAD_IMM_AN_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc::LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PY_SY_UY_WY_SZ2::LOAD_REG_AN_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc::LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UY_WY_SZ2::LOAD_IMM_AY_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc::LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UY_WY_SZ2::LOAD_REG_AY_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc::LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UY_WY_SZ2::LOAD_IMM_AN_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc::LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UY_WY_SZ2::LOAD_REG_AN_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AY_PN_SY_UY_WN_SZ2::LOAD_IMM_AY_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AY_PN_SY_UY_WN_SZ2::LOAD_REG_AY_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AY_PN_SY_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMM_AN_PN_SY_UY_WN_SZ2::LOAD_IMM_AN_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_REG_AN_PN_SY_UY_WN_SZ2::LOAD_REG_AN_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REG_AN_PN_SY_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc::LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_IMMD_AY_PY_SN_UN_WY_SZ4::LOAD_IMMD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc::LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_REGD_AY_PY_SN_UN_WY_SZ4::LOAD_REGD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc::LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_IMMD_AN_PY_SN_UN_WY_SZ4::LOAD_IMMD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc::LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_REGD_AN_PY_SN_UN_WY_SZ4::LOAD_REGD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc::LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_IMMD_AY_PN_SN_UN_WY_SZ4::LOAD_IMMD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc::LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_REGD_AY_PN_SN_UN_WY_SZ4::LOAD_REGD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc::LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_IMMD_AN_PN_SN_UN_WY_SZ4::LOAD_IMMD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc::LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_REGD_AN_PN_SN_UN_WY_SZ4::LOAD_REGD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_IMMD_AY_PN_SN_UN_WN_SZ4::LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_REGD_AY_PN_SN_UN_WN_SZ4::LOAD_REGD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#endif
    }

    LOAD_IMMD_AN_PN_SN_UN_WN_SZ4::LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LOAD_REGD_AN_PN_SN_UN_WN_SZ4::LOAD_REGD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new LOAD_REGD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#endif
    }

    RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc::RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, 8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8::RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 1 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 1
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, 8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc::RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8::RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 0 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc::RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, -8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8::RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 1 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 1
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, -8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc::RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8::RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 0 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc::RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, 8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8::RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 1 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 1
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, 8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc::RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8::RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 0 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc::RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, -8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8::RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 1 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 1
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, -8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc::RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8::RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 0 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[0]->setFirstMicroop();
        uops[uopIdx]->setLastMicroop();
#endif
    }

    PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1::PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("pld", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1::PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("pld", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1::PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("pld", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("pld", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1::PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("pldw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1::PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("pldw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1::PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("pldw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("pldw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1::PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("pli", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInstPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1::PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("pli", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsInstPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1::PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("pli", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInstPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("pli", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsInstPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4::LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrex", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2::LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrexh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrexb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    LDREXD_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4::LDREXD_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("ldrexd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDREXD_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4::VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("vldr", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4::VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("vldr", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            /* Also set flags on the macroop so that pre-microop decomposition
                branch prediction can work */
            setFlag(StaticInst::IsControl);
            setFlag(StaticInst::IsIndirectControl);
            if (conditional) {
                uops[2]->setFlag(StaticInst::IsCondControl);
                setFlag(StaticInst::IsCondControl);
            } else {
                uops[2]->setFlag(StaticInst::IsUncondControl);
                setFlag(StaticInst::IsUncondControl);
            }
            if (_base == INTREG_SP && _add && _imm == 4 && 0) {
                uops[2]->setFlag(StaticInst::IsReturn);
                setFlag(StaticInst::IsReturn);
            }
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[0]->setFirstMicroop();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    VLDR_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4::VLDR_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("vldr", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VLDR_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    VLDR_LOAD_IMMD_AN_PN_SN_UN_WN_SZ4::VLDR_LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("vldr", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VLDR_LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRB64_IMM::LDRB64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRB64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRB64_PREAcc::LDRB64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRB64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRB64_PRE::LDRB64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRB64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRB64_POSTAcc::LDRB64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRB64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRB64_POST::LDRB64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRB64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRB64_REG::LDRB64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldrb", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRB64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBW64_IMM::LDRSBW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBW64_PREAcc::LDRSBW64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBW64_PRE::LDRSBW64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBW64_POSTAcc::LDRSBW64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBW64_POST::LDRSBW64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBW64_REG::LDRSBW64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldrsb", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBW64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBX64_IMM::LDRSBX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBX64_PREAcc::LDRSBX64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBX64_PRE::LDRSBX64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBX64_POSTAcc::LDRSBX64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBX64_POST::LDRSBX64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSBX64_REG::LDRSBX64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldrsb", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSBX64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRH64_IMM::LDRH64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRH64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRH64_PREAcc::LDRH64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRH64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRH64_PRE::LDRH64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRH64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRH64_POSTAcc::LDRH64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRH64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRH64_POST::LDRH64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRH64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRH64_REG::LDRH64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldrh", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRH64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHW64_IMM::LDRSHW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHW64_PREAcc::LDRSHW64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHW64_PRE::LDRSHW64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHW64_POSTAcc::LDRSHW64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHW64_POST::LDRSHW64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHW64_REG::LDRSHW64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldrsh", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHW64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHX64_IMM::LDRSHX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHX64_PREAcc::LDRSHX64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHX64_PRE::LDRSHX64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHX64_POSTAcc::LDRSHX64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHX64_POST::LDRSHX64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSHX64_REG::LDRSHX64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldrsh", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSHX64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSW64_IMM::LDRSW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldrsw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSW64_PREAcc::LDRSW64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSW64_PRE::LDRSW64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldrsw", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSW64_POSTAcc::LDRSW64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSW64_POST::LDRSW64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldrsw", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSW64_REG::LDRSW64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldrsw", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSW64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRW64_IMM::LDRW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRW64_PREAcc::LDRW64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRW64_PRE::LDRW64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRW64_POSTAcc::LDRW64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRW64_POST::LDRW64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRW64_REG::LDRW64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldr", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRW64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRX64_IMM::LDRX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRX64_PREAcc::LDRX64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRX64_PRE::LDRX64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRX64_POSTAcc::LDRX64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRX64_POST::LDRX64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRX64_REG::LDRX64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldr", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRX64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRBFP64_IMM::LDRBFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldr", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRBFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRBFP64_PREAcc::LDRBFP64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRBFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRBFP64_PRE::LDRBFP64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRBFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRBFP64_POSTAcc::LDRBFP64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRBFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRBFP64_POST::LDRBFP64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRBFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRBFP64_REG::LDRBFP64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldr", machInst, FloatMemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRBFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRHFP64_IMM::LDRHFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldr", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRHFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRHFP64_PREAcc::LDRHFP64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRHFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRHFP64_PRE::LDRHFP64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRHFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRHFP64_POSTAcc::LDRHFP64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRHFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRHFP64_POST::LDRHFP64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRHFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRHFP64_REG::LDRHFP64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldr", machInst, FloatMemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRHFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_IMM::LDRSFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldr", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_PREAcc::LDRSFP64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_PRE::LDRSFP64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_POSTAcc::LDRSFP64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_POST::LDRSFP64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_REG::LDRSFP64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldr", machInst, FloatMemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_IMM::LDRDFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldr", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_PREAcc::LDRDFP64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_PRE::LDRDFP64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_POSTAcc::LDRDFP64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_POST::LDRDFP64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_REG::LDRDFP64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldr", machInst, FloatMemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    PRFM64_IMM::PRFM64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("prfm", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new PRFM64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    PRFM64_REG::PRFM64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("prfm", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new PRFM64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    PRFM64_LIT::PRFM64_LIT(ExtMachInst machInst,
            IntRegIndex _dest, int64_t _imm)
         : ArmISA::MemoryLiteral64("prfm", machInst, MemReadOp,
                 (IntRegIndex)_dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsDataPrefetch] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new PRFM64_LIT(machInst, _dest, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    PRFUM64_IMM::PRFUM64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("prfum", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new PRFUM64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURB64_IMM::LDURB64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldurb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURB64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURSBW64_IMM::LDURSBW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldursb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURSBW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURSBX64_IMM::LDURSBX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldursb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURSBX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURH64_IMM::LDURH64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldurh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURH64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURSHW64_IMM::LDURSHW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldursh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURSHW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURSHX64_IMM::LDURSHX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldursh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURSHX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURSW64_IMM::LDURSW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldursw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURSW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURW64_IMM::LDURW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldur", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURX64_IMM::LDURX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldur", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURBFP64_IMM::LDURBFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldur", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURBFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURHFP64_IMM::LDURHFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldur", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURHFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURSFP64_IMM::LDURSFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldur", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURSFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDURDFP64_IMM::LDURDFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldur", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDURDFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRB64_IMM::LDTRB64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldtrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRB64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRSBW64_IMM::LDTRSBW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldtrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRSBW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRSBX64_IMM::LDTRSBX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldtrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRSBX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRH64_IMM::LDTRH64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldtrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRH64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRSHW64_IMM::LDTRSHW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldtrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRSHW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRSHX64_IMM::LDTRSHX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldtrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRSHX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRSW64_IMM::LDTRSW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldtrsw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRSW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRW64_IMM::LDTRW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldtr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDTRX64_IMM::LDTRX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("ldtr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDTRX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSWL64_LIT::LDRSWL64_LIT(ExtMachInst machInst,
            IntRegIndex _dest, int64_t _imm)
         : ArmISA::MemoryLiteral64("ldrsw", machInst, MemReadOp,
                 (IntRegIndex)_dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSWL64_LIT(machInst, _dest, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRWL64_LIT::LDRWL64_LIT(ExtMachInst machInst,
            IntRegIndex _dest, int64_t _imm)
         : ArmISA::MemoryLiteral64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRWL64_LIT(machInst, _dest, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRXL64_LIT::LDRXL64_LIT(ExtMachInst machInst,
            IntRegIndex _dest, int64_t _imm)
         : ArmISA::MemoryLiteral64("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRXL64_LIT(machInst, _dest, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRSFP64_LIT::LDRSFP64_LIT(ExtMachInst machInst,
            IntRegIndex _dest, int64_t _imm)
         : ArmISA::MemoryLiteral64("ldr", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRSFP64_LIT(machInst, _dest, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDRDFP64_LIT::LDRDFP64_LIT(ExtMachInst machInst,
            IntRegIndex _dest, int64_t _imm)
         : ArmISA::MemoryLiteral64("ldr", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDRDFP64_LIT(machInst, _dest, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDARX64::LDARX64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base)
         : ArmISA::MemoryRaw64("ldar", machInst, MemReadOp, _dest, _base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDARW64::LDARW64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base)
         : ArmISA::MemoryRaw64("ldar", machInst, MemReadOp, _dest, _base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDARH64::LDARH64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base)
         : ArmISA::MemoryRaw64("ldarh", machInst, MemReadOp, _dest, _base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDARB64::LDARB64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base)
         : ArmISA::MemoryRaw64("ldarb", machInst, MemReadOp, _dest, _base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDAXRX64::LDAXRX64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("ldaxr", machInst, MemReadOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDAXRW64::LDAXRW64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("ldaxr", machInst, MemReadOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDAXRH64::LDAXRH64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("ldaxrh", machInst, MemReadOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDAXRB64::LDAXRB64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("ldaxrb", machInst, MemReadOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
    }

    LDXRX64::LDXRX64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("ldxr", machInst, MemReadOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
    }

    LDXRW64::LDXRW64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("ldxr", machInst, MemReadOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
    }

    LDXRH64::LDXRH64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("ldxrh", machInst, MemReadOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
    }

    LDXRB64::LDXRB64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("ldxrb", machInst, MemReadOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
    }

    MicroLdPairUop::MicroLdPairUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("ldp_uop", machInst, MemReadOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdPairFp8Uop::MicroLdPairFp8Uop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("ldp_fp8_uop", machInst, FloatMemReadOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest2 * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest2 * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest2 * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest2 * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdFp16Uop::MicroLdFp16Uop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryImm64("ldfp16_uop", machInst, FloatMemReadOp,
                 _dest, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdFp16RegUop::MicroLdFp16RegUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("ldfp16reg_uop", machInst, FloatMemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new MicroLdFp16RegUop(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    LDAXPW64::LDAXPW64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("ldaxp", machInst, MemReadOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    LDAXPX64::LDAXPX64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("ldaxp", machInst, MemReadOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsWriteBarrier] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    LDXPW64::LDXPW64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("ldxp", machInst, MemReadOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    LDXPX64::LDXPX64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("ldxp", machInst, MemReadOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrXImmUop::MicroLdrXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryImm64("ldrxi_uop", machInst, MemReadOp,
                 _dest, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrXRegUop::MicroLdrXRegUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryReg64("ldrxr_uop", machInst, MemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrXLitUop::MicroLdrXLitUop(ExtMachInst machInst,
            IntRegIndex _dest, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryLiteral64("ldrxl_uop", machInst, MemReadOp,
                 (IntRegIndex)_dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrFpXImmUop::MicroLdrFpXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryImm64("ldrfpxi_uop", machInst, FloatMemReadOp,
                 _dest, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrFpXRegUop::MicroLdrFpXRegUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryReg64("ldrfpxr_uop", machInst, FloatMemReadOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrFpXLitUop::MicroLdrFpXLitUop(ExtMachInst machInst,
            IntRegIndex _dest, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryLiteral64("ldrfpxl_uop", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdFp16LitUop::MicroLdFp16LitUop(ExtMachInst machInst,
            IntRegIndex _dest, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryLiteral64("ldfp16_lit__uop", machInst, FloatMemReadOp,
                 (IntRegIndex)_dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrDUXImmUop::MicroLdrDUXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("ldrduxi_uop", machInst, MemReadOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrDSXImmUop::MicroLdrDSXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("ldrdsxi_uop", machInst, MemReadOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroLdrDFpXImmUop::MicroLdrDFpXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("ldrdfpxi_uop", machInst, FloatMemReadOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest2 * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest2 * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest2 * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest2 * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    Svc::Svc(ExtMachInst machInst, uint64_t _imm)
        : ImmOp("svc", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSyscall] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        Smc::Smc(ExtMachInst machInst)  : PredOp("smc", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    Hvc::Hvc(ExtMachInst machInst, uint64_t _imm)
        : ImmOp("hvc", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        Eret::Eret(ExtMachInst machInst)  : PredOp("eret", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_ELR_HYP + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    MrsCpsr::MrsCpsr(ExtMachInst machInst,
                                          IntRegIndex _dest)
        : MrsOp("mrs", machInst, IntAluOp, _dest)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MrsSpsr::MrsSpsr(ExtMachInst machInst,
                                          IntRegIndex _dest)
        : MrsOp("mrs", machInst, IntAluOp, _dest)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MrsBankedReg::MrsBankedReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint8_t     _sysM,
                                          bool        _r)
        : MrsOp("mrs", machInst, IntAluOp, _dest),
          byteMask(_sysM), r(_r)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = decodeMrsMsrBankedIntRegIndex(byteMask, r);
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MsrBankedReg::MsrBankedReg(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          uint8_t     _sysM,
                                          bool        _r)
        : MsrRegOp("msr", machInst, IntAluOp, _op1, _sysM),
          r(_r)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = decodeMrsMsrBankedIntRegIndex(byteMask, r);
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MsrCpsrReg::MsrCpsrReg(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          uint8_t mask)
        : MsrRegOp("msr", machInst, IntAluOp, _op1, mask)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MsrSpsrReg::MsrSpsrReg(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          uint8_t mask)
        : MsrRegOp("msr", machInst, IntAluOp, _op1, mask)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MsrCpsrImm::MsrCpsrImm(ExtMachInst machInst,
                                          uint32_t imm,
                                          uint8_t mask)
        : MsrImmOp("msr", machInst, IntAluOp, imm, mask)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MsrSpsrImm::MsrSpsrImm(ExtMachInst machInst,
                                          uint32_t imm,
                                          uint8_t mask)
        : MsrImmOp("msr", machInst, IntAluOp, imm, mask)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Rev::Rev(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("rev", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Rev16::Rev16(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("rev16", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Revsh::Revsh(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("revsh", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Rbit::Rbit(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("rbit", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Clz::Clz(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("clz", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Ssat::Ssat(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : RegImmRegShiftOp("ssat", machInst, IntAluOp,
                         _dest, _imm, _op1, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Usat::Usat(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : RegImmRegShiftOp("usat", machInst, IntAluOp,
                         _dest, _imm, _op1, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Ssat16::Ssat16(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("ssat16", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Usat16::Usat16(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("usat16", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Sxtb::Sxtb(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("sxtb", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Sxtab::Sxtab(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp("sxtab", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Sxtb16::Sxtb16(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("sxtb16", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Sxtab16::Sxtab16(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp("sxtab16", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Sxth::Sxth(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("sxth", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Sxtah::Sxtah(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp("sxtah", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Uxtb::Uxtb(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("uxtb", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Uxtab::Uxtab(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp("uxtab", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Uxtb16::Uxtb16(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("uxtb16", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Uxtab16::Uxtab16(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp("uxtab16", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Uxth::Uxth(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("uxth", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Uxtah::Uxtah(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp("uxtah", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Sel::Sel(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("sel", machInst, IntAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_GE + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Usad8::Usad8(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("usad8", machInst, IntAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Usada8::Usada8(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3)
        : RegRegRegRegOp("usada8", machInst, IntAluOp,
                         _dest, _op1, _op2, _op3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        BkptInst::BkptInst(ExtMachInst machInst)  : PredOp("bkpt", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        NopInst::NopInst(ExtMachInst machInst)  : ArmStaticInst("nop", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNop] = true;;
        }

        YieldInst::YieldInst(ExtMachInst machInst)  : PredOp("yield", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        WfeInst::WfeInst(ExtMachInst machInst)  : PredOp("wfe", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;
	flags[IsSerializeAfter] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        WfiInst::WfiInst(ExtMachInst machInst)  : PredOp("wfi", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;
	flags[IsSerializeAfter] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        SevInst::SevInst(ExtMachInst machInst)  : PredOp("sev", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSquashAfter] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        SevlInst::SevlInst(ExtMachInst machInst)  : PredOp("sevl", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSquashAfter] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        ItInst::ItInst(ExtMachInst machInst)  : PredOp("it", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Unknown::Unknown(ExtMachInst machInst)  : UnknownOp("unknown", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    Ubfx::Ubfx(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegRegImmImmOp("ubfx", machInst, IntAluOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Sbfx::Sbfx(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegRegImmImmOp("sbfx", machInst, IntAluOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Bfc::Bfc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegRegImmImmOp("bfc", machInst, IntAluOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Bfi::Bfi(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegRegImmImmOp("bfi", machInst, IntAluOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Mrc14::Mrc14(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : RegRegImmOp("mrc", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HDCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1 + Misc_Reg_Base;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Mcr14::Mcr14(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : RegRegImmOp("mcr", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HDCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Mrc15::Mrc15(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          MiscRegIndex _op1,
                                          uint64_t _imm)
        : RegMiscRegImmOp("mrc", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HDCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1 + Misc_Reg_Base;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Mcr15::Mcr15(ExtMachInst machInst,
                                          MiscRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : MiscRegRegImmOp("mcr", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HDCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Mrrc15::Mrrc15(ExtMachInst machInst,
                                          MiscRegIndex op1,
                                          IntRegIndex dest,
                                          IntRegIndex dest2,
                                          uint32_t    imm)
        : MrrcOp("mrrc", machInst, IntAluOp, op1, dest,
                         dest2, imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Mcrr15::Mcrr15(ExtMachInst machInst,
                                          IntRegIndex op1,
                                          IntRegIndex op2,
                                          MiscRegIndex dest,
                                          uint32_t    imm)
        : McrrOp("mcrr", machInst, IntAluOp, op1, op2,
                         dest, imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        Enterx::Enterx(ExtMachInst machInst)  : PredOp("enterx", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsControl] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Leavex::Leavex(ExtMachInst machInst)  : PredOp("leavex", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsControl] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    Setend::Setend(ExtMachInst machInst, uint64_t _imm)
        : ImmOp("setend", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        Clrex::Clrex(ExtMachInst machInst)  : PredOp("clrex", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_LOCKFLAG + Misc_Reg_Base;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    Isb::Isb(ExtMachInst machInst, uint64_t _imm)
        : ImmOp("isb", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HDCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Dsb::Dsb(ExtMachInst machInst, uint64_t _imm)
        : ImmOp("dsb", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HDCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	flags[IsMemBarrier] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Dmb::Dmb(ExtMachInst machInst, uint64_t _imm)
        : ImmOp("dmb", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HDCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCPTR + Misc_Reg_Base;
	flags[IsMemBarrier] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        Dbg::Dbg(ExtMachInst machInst)  : PredOp("dbg", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    Cps::Cps(ExtMachInst machInst, uint64_t _imm)
        : ImmOp("cps", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        Svc64::Svc64(ExtMachInst machInst)  : ArmStaticInst("svc", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSyscall] = true;;
        }

        Hvc64::Hvc64(ExtMachInst machInst)  : ArmStaticInst("hvc", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSyscall] = true;;
        }

        Smc64::Smc64(ExtMachInst machInst)  : ArmStaticInst("smc", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        }

    Bfm64::Bfm64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegRegImmImmOp64("bfm", machInst, IntAluOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = dest;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Ubfm64::Ubfm64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegRegImmImmOp64("ubfm", machInst, IntAluOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Sbfm64::Sbfm64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegRegImmImmOp64("sbfm", machInst, IntAluOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Extr64::Extr64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp64("extr", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

        Unknown64::Unknown64(ExtMachInst machInst)  : UnknownOp64("unknown", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
        }

        Isb64::Isb64(ExtMachInst machInst)  : ArmStaticInst("isb", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsSerializeAfter] = true;;
        }

        Dsb64::Dsb64(ExtMachInst machInst)  : ArmStaticInst("dsb", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMemBarrier] = true;
	flags[IsSerializeAfter] = true;;
        }

        Dmb64::Dmb64(ExtMachInst machInst)  : ArmStaticInst("dmb", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMemBarrier] = true;;
        }

        Clrex64::Clrex64(ExtMachInst machInst)  : ArmStaticInst("clrex", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_LOCKFLAG + Misc_Reg_Base;;
        }

#endif
#if __SPLIT == 2

    STRB64_IMM::STRB64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRB64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRB64_PREAcc::STRB64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRB64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRB64_PRE::STRB64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRB64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRB64_POSTAcc::STRB64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRB64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRB64_POST::STRB64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRB64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRB64_REG::STRB64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("strb", machInst, MemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRB64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRH64_IMM::STRH64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRH64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRH64_PREAcc::STRH64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRH64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRH64_PRE::STRH64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRH64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRH64_POSTAcc::STRH64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRH64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRH64_POST::STRH64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRH64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRH64_REG::STRH64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("strh", machInst, MemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRH64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRW64_IMM::STRW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRW64_PREAcc::STRW64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRW64_PRE::STRW64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRW64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRW64_POSTAcc::STRW64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRW64_POST::STRW64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRW64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRW64_REG::STRW64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("str", machInst, MemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRW64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRX64_IMM::STRX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRX64_PREAcc::STRX64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRX64_PRE::STRX64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRX64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRX64_POSTAcc::STRX64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRX64_POST::STRX64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRX64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRX64_REG::STRX64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("str", machInst, MemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRX64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRBFP64_IMM::STRBFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("str", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRBFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRBFP64_PREAcc::STRBFP64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRBFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRBFP64_PRE::STRBFP64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRBFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRBFP64_POSTAcc::STRBFP64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRBFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRBFP64_POST::STRBFP64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRBFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRBFP64_REG::STRBFP64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("str", machInst, FloatMemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRBFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRHFP64_IMM::STRHFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("str", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRHFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRHFP64_PREAcc::STRHFP64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRHFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRHFP64_PRE::STRHFP64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRHFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRHFP64_POSTAcc::STRHFP64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRHFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRHFP64_POST::STRHFP64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRHFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRHFP64_REG::STRHFP64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("str", machInst, FloatMemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRHFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRSFP64_IMM::STRSFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("str", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRSFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRSFP64_PREAcc::STRSFP64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRSFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRSFP64_PRE::STRSFP64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRSFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRSFP64_POSTAcc::STRSFP64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRSFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRSFP64_POST::STRSFP64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRSFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRSFP64_REG::STRSFP64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("str", machInst, FloatMemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRSFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRDFP64_IMM::STRDFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("str", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRDFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STRDFP64_PREAcc::STRDFP64_PREAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRDFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRDFP64_PRE::STRDFP64_PRE(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPreIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRDFP64_PREAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRDFP64_POSTAcc::STRDFP64_POSTAcc(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRDFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRDFP64_POST::STRDFP64_POST(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryPostIndex64("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRDFP64_POSTAcc(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddXiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STRDFP64_REG::STRDFP64_REG(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt)
         : ArmISA::MemoryReg64("str", machInst, FloatMemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STRDFP64_REG(machInst, _dest, _base, _offset,
                                   _type, _shiftAmt);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURB64_IMM::STURB64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("sturb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURB64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURH64_IMM::STURH64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("sturh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURH64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURW64_IMM::STURW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("stur", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURX64_IMM::STURX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("stur", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURBFP64_IMM::STURBFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("stur", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURBFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURHFP64_IMM::STURHFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("stur", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURHFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURSFP64_IMM::STURSFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("stur", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURSFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STURDFP64_IMM::STURDFP64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("stur", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STURDFP64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STTRB64_IMM::STTRB64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("sttrb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STTRB64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STTRH64_IMM::STTRH64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("sttrh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STTRH64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STTRW64_IMM::STTRW64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("sttr", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STTRW64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STTRX64_IMM::STTRX64_IMM(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryImm64("sttr", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STTRX64_IMM(machInst, _dest, _base, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STLRX64::STLRX64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base)
         : ArmISA::MemoryRaw64("stlr", machInst, MemWriteOp, _dest, _base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLRW64::STLRW64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base)
         : ArmISA::MemoryRaw64("stlr", machInst, MemWriteOp, _dest, _base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLRH64::STLRH64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base)
         : ArmISA::MemoryRaw64("stlrh", machInst, MemWriteOp, _dest, _base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLRB64::STLRB64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base)
         : ArmISA::MemoryRaw64("stlrb", machInst, MemWriteOp, _dest, _base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLXRX64::STLXRX64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("stlxr", machInst, MemWriteOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLXRW64::STLXRW64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("stlxr", machInst, MemWriteOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLXRH64::STLXRH64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("stlxrh", machInst, MemWriteOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
    }

    STLXRB64::STLXRB64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("stlxrb", machInst, MemWriteOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
    }

    STXRX64::STXRX64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("stxr", machInst, MemWriteOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
    }

    STXRW64::STXRW64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("stxr", machInst, MemWriteOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
    }

    STXRH64::STXRH64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("stxrh", machInst, MemWriteOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
    }

    STXRB64::STXRB64(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _result)
         : ArmISA::MemoryEx64("stxrb", machInst, MemWriteOp,
                          _dest, _base, _result)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
    }

    STLXPW64::STLXPW64(ExtMachInst machInst,
            IntRegIndex _result, IntRegIndex _dest, IntRegIndex _dest2,
            IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryDImmEx64("stlxp", machInst, MemWriteOp,
                 _result, _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest2;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
        assert(!0);
    }

    STLXPX64::STLXPX64(ExtMachInst machInst,
            IntRegIndex _result, IntRegIndex _dest, IntRegIndex _dest2,
            IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryDImmEx64("stlxp", machInst, MemWriteOp,
                 _result, _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemBarrier] = true;
	flags[IsMemRef] = true;
	flags[IsReadBarrier] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;
	flags[IsWriteBarrier] = true;;
        assert(!0);
    }

    STXPW64::STXPW64(ExtMachInst machInst,
            IntRegIndex _result, IntRegIndex _dest, IntRegIndex _dest2,
            IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryDImmEx64("stxp", machInst, MemWriteOp,
                 _result, _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest2;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        assert(!0);
    }

    STXPX64::STXPX64(ExtMachInst machInst,
            IntRegIndex _result, IntRegIndex _dest, IntRegIndex _dest2,
            IntRegIndex _base, int64_t _imm)
         : ArmISA::MemoryDImmEx64("stxp", machInst, MemWriteOp,
                 _result, _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        assert(!0);
    }

    MicroStrXImmUop::MicroStrXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryImm64("strxi_uop", machInst, MemWriteOp,
                 _dest, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrXRegUop::MicroStrXRegUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryReg64("strxr_uop", machInst, MemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrFpXImmUop::MicroStrFpXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryImm64("strfpxi_uop", machInst, FloatMemWriteOp,
                 _dest, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrFpXRegUop::MicroStrFpXRegUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryReg64("strfpxr_uop", machInst, FloatMemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrQBFpXImmUop::MicroStrQBFpXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryImm64("strqbfpxi_uop", machInst, FloatMemWriteOp,
                 _dest, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrQBFpXRegUop::MicroStrQBFpXRegUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryReg64("strqbfpxr_uop", machInst, FloatMemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrQTFpXImmUop::MicroStrQTFpXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, int64_t _imm,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryImm64("strqtfpxi_uop", machInst, FloatMemWriteOp,
                 _dest, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrQTFpXRegUop::MicroStrQTFpXRegUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _base, IntRegIndex _offset,
            ArmExtendType _type, uint32_t _shiftAmt,
            bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryReg64("strqtfpxr_uop", machInst, FloatMemWriteOp,
                 _dest, _base, _offset, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = offset;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrDXImmUop::MicroStrDXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("strdxi_uop", machInst, MemWriteOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = dest2;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    MicroStrDFpXImmUop::MicroStrDFpXImmUop(ExtMachInst machInst,
            IntRegIndex _dest, IntRegIndex _dest2, IntRegIndex _base,
            int64_t _imm, bool noAlloc, bool exclusive, bool acrel)
         : ArmISA::MemoryDImm64("strdfpxi_uop", machInst, FloatMemWriteOp,
                 _dest, _dest2, _base, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        assert(!0);
        setExcAcRel(exclusive, acrel);
    }

    STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc::STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UN_WY_SZ4::STORE_IMM_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UN_WY_SZ4Acc::STORE_REG_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UN_WY_SZ4::STORE_REG_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc::STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UN_WY_SZ4::STORE_IMM_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UN_WY_SZ4Acc::STORE_REG_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UN_WY_SZ4::STORE_REG_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc::STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UN_WY_SZ4::STORE_IMM_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UN_WY_SZ4Acc::STORE_REG_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UN_WY_SZ4::STORE_REG_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc::STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UN_WY_SZ4::STORE_IMM_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UN_WY_SZ4Acc::STORE_REG_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UN_WY_SZ4::STORE_REG_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UN_WN_SZ4::STORE_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UN_WN_SZ4::STORE_REG_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UN_WN_SZ4::STORE_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UN_WN_SZ4::STORE_REG_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc::STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UY_WY_SZ4::STORE_IMM_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UY_WY_SZ4Acc::STORE_REG_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UY_WY_SZ4::STORE_REG_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc::STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UY_WY_SZ4::STORE_IMM_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UY_WY_SZ4Acc::STORE_REG_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UY_WY_SZ4::STORE_REG_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc::STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UY_WY_SZ4::STORE_IMM_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UY_WY_SZ4Acc::STORE_REG_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UY_WY_SZ4::STORE_REG_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc::STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UY_WY_SZ4::STORE_IMM_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UY_WY_SZ4Acc::STORE_REG_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UY_WY_SZ4::STORE_REG_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UY_WN_SZ4::STORE_IMM_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UY_WN_SZ4::STORE_REG_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UY_WN_SZ4::STORE_IMM_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UY_WN_SZ4::STORE_REG_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc::STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UN_WY_SZ1::STORE_IMM_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UN_WY_SZ1Acc::STORE_REG_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UN_WY_SZ1::STORE_REG_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc::STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UN_WY_SZ1::STORE_IMM_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UN_WY_SZ1Acc::STORE_REG_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UN_WY_SZ1::STORE_REG_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc::STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UN_WY_SZ1::STORE_IMM_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UN_WY_SZ1Acc::STORE_REG_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UN_WY_SZ1::STORE_REG_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc::STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UN_WY_SZ1::STORE_IMM_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UN_WY_SZ1Acc::STORE_REG_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UN_WY_SZ1::STORE_REG_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UN_WN_SZ1::STORE_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UN_WN_SZ1::STORE_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UN_WN_SZ1::STORE_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UN_WN_SZ1::STORE_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc::STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UY_WY_SZ1::STORE_IMM_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UY_WY_SZ1Acc::STORE_REG_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UY_WY_SZ1::STORE_REG_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc::STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UY_WY_SZ1::STORE_IMM_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UY_WY_SZ1Acc::STORE_REG_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UY_WY_SZ1::STORE_REG_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc::STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UY_WY_SZ1::STORE_IMM_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UY_WY_SZ1Acc::STORE_REG_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UY_WY_SZ1::STORE_REG_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc::STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UY_WY_SZ1::STORE_IMM_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UY_WY_SZ1Acc::STORE_REG_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UY_WY_SZ1::STORE_REG_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UY_WN_SZ1::STORE_IMM_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UY_WN_SZ1::STORE_REG_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UY_WN_SZ1::STORE_IMM_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UY_WN_SZ1::STORE_REG_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc::STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UN_WY_SZ2::STORE_IMM_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UN_WY_SZ2Acc::STORE_REG_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UN_WY_SZ2::STORE_REG_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc::STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UN_WY_SZ2::STORE_IMM_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UN_WY_SZ2Acc::STORE_REG_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UN_WY_SZ2::STORE_REG_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc::STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UN_WY_SZ2::STORE_IMM_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UN_WY_SZ2Acc::STORE_REG_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UN_WY_SZ2::STORE_REG_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc::STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UN_WY_SZ2::STORE_IMM_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UN_WY_SZ2Acc::STORE_REG_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UN_WY_SZ2::STORE_REG_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UN_WN_SZ2::STORE_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UN_WN_SZ2::STORE_REG_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UN_WN_SZ2::STORE_IMM_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UN_WN_SZ2::STORE_REG_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc::STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PY_SN_UY_WY_SZ2::STORE_IMM_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UY_WY_SZ2Acc::STORE_REG_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PY_SN_UY_WY_SZ2::STORE_REG_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc::STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PY_SN_UY_WY_SZ2::STORE_IMM_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UY_WY_SZ2Acc::STORE_REG_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PY_SN_UY_WY_SZ2::STORE_REG_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc::STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UY_WY_SZ2::STORE_IMM_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UY_WY_SZ2Acc::STORE_REG_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UY_WY_SZ2::STORE_REG_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc::STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UY_WY_SZ2::STORE_IMM_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UY_WY_SZ2Acc::STORE_REG_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UY_WY_SZ2::STORE_REG_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AY_PN_SN_UY_WN_SZ2::STORE_IMM_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AY_PN_SN_UY_WN_SZ2::STORE_REG_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMM_AN_PN_SN_UY_WN_SZ2::STORE_IMM_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REG_AN_PN_SN_UY_WN_SZ2::STORE_REG_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc::SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8::SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, IntAluOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AY_PY_SN_UN_WN_SZ8::SRS_STORE_IMM_AY_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AY_PY_SN_UN_WN_SZ8(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc::SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              -8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8::SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, IntAluOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              -8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AN_PY_SN_UN_WN_SZ8::SRS_STORE_IMM_AN_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AN_PY_SN_UN_WN_SZ8(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc::SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8::SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, IntAluOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AY_PN_SN_UN_WN_SZ8::SRS_STORE_IMM_AY_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AY_PN_SN_UN_WN_SZ8(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc::SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              -8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8::SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, IntAluOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              -8);;
        uops[1]->setLastMicroop();
#endif
    }

    SRS_STORE_IMM_AN_PN_SN_UN_WN_SZ8::SRS_STORE_IMM_AN_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AN_PN_SN_UN_WN_SZ8(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc::STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AY_PY_SN_UN_WY_SZ4::STORE_IMMD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc::STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AY_PY_SN_UN_WY_SZ4::STORE_REGD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc::STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AN_PY_SN_UN_WY_SZ4::STORE_IMMD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc::STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AN_PY_SN_UN_WY_SZ4::STORE_REGD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc::STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AY_PN_SN_UN_WY_SZ4::STORE_IMMD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc::STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AY_PN_SN_UN_WY_SZ4::STORE_REGD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc::STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AN_PN_SN_UN_WY_SZ4::STORE_IMMD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc::STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AN_PN_SN_UN_WY_SZ4::STORE_REGD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AY_PN_SN_UN_WN_SZ4::STORE_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AY_PN_SN_UN_WN_SZ4::STORE_REGD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryDReg>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_IMMD_AN_PN_SN_UN_WN_SZ4::STORE_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STORE_REGD_AN_PN_SN_UN_WN_SZ4::STORE_REGD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryDReg>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STREX_STORE_IMM_AY_PN_SN_UN_WN_SZ4::STREX_STORE_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _base,
            bool _add, int32_t _imm)
         : MemoryOffset<MemoryExImm>("strex", machInst, MemWriteOp,
                 (IntRegIndex)_result, (IntRegIndex)_dest,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STREX_STORE_IMM_AY_PN_SN_UN_WN_SZ4(machInst, _result, _dest,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STREXH_STORE_IMM_AY_PN_SN_UN_WN_SZ2::STREXH_STORE_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _base,
            bool _add, int32_t _imm)
         : MemoryOffset<MemoryExImm>("strexh", machInst, MemWriteOp,
                 (IntRegIndex)_result, (IntRegIndex)_dest,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STREXH_STORE_IMM_AY_PN_SN_UN_WN_SZ2(machInst, _result, _dest,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STREXB_STORE_IMM_AY_PN_SN_UN_WN_SZ1::STREXB_STORE_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _base,
            bool _add, int32_t _imm)
         : MemoryOffset<MemoryExImm>("strexb", machInst, MemWriteOp,
                 (IntRegIndex)_result, (IntRegIndex)_dest,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STREXB_STORE_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _result, _dest,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    STREXD_STORE_IMMD_AY_PN_SN_UN_WN_SZ4::STREXD_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryExDImm>("strexd", machInst, MemWriteOp,
                 (IntRegIndex)_result,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STREXD_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, _result, _dest, _dest2,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    VSTR_STORE_IMM_AY_PN_SN_UN_WN_SZ4::VSTR_STORE_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("vstr", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VSTR_STORE_IMM_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    VSTR_STORE_IMM_AN_PN_SN_UN_WN_SZ4::VSTR_STORE_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("vstr", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VSTR_STORE_IMM_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[0]->setFirstMicroop();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    VSTR_STORE_IMMD_AY_PN_SN_UN_WN_SZ4::VSTR_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("vstr", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VSTR_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    VSTR_STORE_IMMD_AN_PN_SN_UN_WN_SZ4::VSTR_STORE_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("vstr", machInst, FloatMemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VSTR_STORE_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setFirstMicroop();
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    Swp::Swp(ExtMachInst machInst,
            uint32_t _dest, uint32_t _op1, uint32_t _base)
         : Swap("swp", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_op1, (IntRegIndex)_base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Swpb::Swpb(ExtMachInst machInst,
            uint32_t _dest, uint32_t _op1, uint32_t _base)
         : Swap("swpb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_op1, (IntRegIndex)_base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroLdrUop::MicroLdrUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("ldr_uop", machInst, MemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroLdrRetUop::MicroLdrRetUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("ldr_ret_uop", machInst, MemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroLdrFpUop::MicroLdrFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("ldrfp_uop", machInst, FloatMemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ura + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroLdrDBFpUop::MicroLdrDBFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("ldrfp_uop", machInst, FloatMemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ura + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroLdrDTFpUop::MicroLdrDTFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("ldrfp_uop", machInst, FloatMemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ura + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroStrUop::MicroStrUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("str_uop", machInst, MemWriteOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroStrFpUop::MicroStrFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("strfp_uop", machInst, FloatMemWriteOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroStrDBFpUop::MicroStrDBFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("strfp_uop", machInst, FloatMemWriteOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroStrDTFpUop::MicroStrDTFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("strfp_uop", machInst, FloatMemWriteOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroLdr2Uop::MicroLdr2Uop(ExtMachInst machInst,
                                   RegIndex _dreg1,
                                   RegIndex _dreg2,
                                   RegIndex _base,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemPairOp("ldr2_uop", machInst, MemReadOp,
                         _dreg1, _dreg2, _base, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroAddiUop::MicroAddiUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   int32_t _imm)
        : MicroIntImmOp("addi_uop", machInst, IntAluOp,
                         _ura, _urb, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroAddXiUop::MicroAddXiUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   int32_t _imm)
        : MicroIntImmXOp("addxi_uop", machInst, IntAluOp,
                         _ura, _urb, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
    }

    MicroAddXiSpAlignUop::MicroAddXiSpAlignUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   int32_t _imm)
        : MicroIntImmXOp("addxi_uop", machInst, IntAluOp,
                         _ura, _urb, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = urb;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
    }

    MicroSubiUop::MicroSubiUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   int32_t _imm)
        : MicroIntImmOp("subi_uop", machInst, IntAluOp,
                         _ura, _urb, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroSubXiUop::MicroSubXiUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   int32_t _imm)
        : MicroIntImmXOp("subxi_uop", machInst, IntAluOp,
                         _ura, _urb, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
    }

    MicroAddUop::MicroAddUop(ExtMachInst machInst,
                                   RegIndex _ura, RegIndex _urb, RegIndex _urc,
                                   int32_t _shiftAmt, ArmShiftType _shiftType)
        : MicroIntRegOp("add_uop", machInst, IntAluOp,
                         _ura, _urb, _urc, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	_srcRegIdx[_numSrcRegs++] = urc;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroSubUop::MicroSubUop(ExtMachInst machInst,
                                   RegIndex _ura, RegIndex _urb, RegIndex _urc,
                                   int32_t _shiftAmt, ArmShiftType _shiftType)
        : MicroIntRegOp("sub_uop", machInst, IntAluOp,
                         _ura, _urb, _urc, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	_srcRegIdx[_numSrcRegs++] = urc;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroAddXERegUop::MicroAddXERegUop(ExtMachInst machInst,
                                   RegIndex _ura, RegIndex _urb, RegIndex _urc,
                                   ArmExtendType _type, uint32_t _shiftAmt)
        : MicroIntRegXOp("addxr_uop", machInst, IntAluOp,
                         _ura, _urb, _urc, _type, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	_srcRegIdx[_numSrcRegs++] = urc;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
    }

    MicroUopRegMov::MicroUopRegMov(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb)
        : MicroIntMov("uopReg_uop", machInst, IntAluOp,
                         _ura, _urb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroUopRegMovRet::MicroUopRegMovRet(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb)
        : MicroIntMov("movret_uop", machInst, IntAluOp,
                         _ura, _urb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroUopSetPCCPSR::MicroUopSetPCCPSR(ExtMachInst machInst,
                                   IntRegIndex _ura,
                                   IntRegIndex _urb,
                                   IntRegIndex _urc)
          : MicroSetPCCPSR("uopSet_uop", machInst, IntAluOp,
                           _ura, _urb, _urc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urc;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = urb;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            flags[IsCondControl] = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        } else {
            flags[IsUncondControl] = true;
        }
    }

LdmStm::LdmStm(ExtMachInst machInst, IntRegIndex rn,
        bool index, bool up, bool user, bool writeback, bool load,
        uint32_t reglist)
    : MacroMemOp("ldmstm", machInst, IntAluOp, rn,
                     index, up, user, writeback, load, reglist)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
        }
    }
}


LdpStp::LdpStp(const char *mnemonic, ExtMachInst machInst,
        uint32_t size, bool fp, bool load, bool noAlloc, bool signExt,
        bool exclusive, bool acrel, uint32_t imm, AddrMode mode,
        IntRegIndex rn, IntRegIndex rt, IntRegIndex rt2)
    : PairMemOp(mnemonic, machInst, IntAluOp, size,
                     fp, load, noAlloc, signExt, exclusive, acrel,
                     imm, mode, rn, rt, rt2)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
}

BigFpMemImm::BigFpMemImm(const char *mnemonic, ExtMachInst machInst,
        bool load, IntRegIndex dest, IntRegIndex base, int64_t imm)
    : BigFpMemImmOp(mnemonic, machInst, IntAluOp, load, dest, base, imm)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
}

BigFpMemPre::BigFpMemPre(const char *mnemonic, ExtMachInst machInst,
        bool load, IntRegIndex dest, IntRegIndex base, int64_t imm)
    : BigFpMemPreOp(mnemonic, machInst, IntAluOp, load, dest, base, imm)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
}

BigFpMemPost::BigFpMemPost(const char *mnemonic, ExtMachInst machInst,
        bool load, IntRegIndex dest, IntRegIndex base, int64_t imm)
    : BigFpMemPostOp(mnemonic, machInst, IntAluOp, load, dest, base, imm)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
}

BigFpMemReg::BigFpMemReg(const char *mnemonic, ExtMachInst machInst,
        bool load, IntRegIndex dest, IntRegIndex base,
        IntRegIndex offset, ArmExtendType type, int64_t imm)
    : BigFpMemRegOp(mnemonic, machInst, IntAluOp, load, dest, base,
                     offset, type, imm)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
}

BigFpMemLit::BigFpMemLit(const char *mnemonic, ExtMachInst machInst,
        IntRegIndex dest, int64_t imm)
    : BigFpMemLitOp(mnemonic, machInst, IntAluOp, dest, imm)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
}

VldMult::VldMult(ExtMachInst machInst, unsigned width,
        RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
        uint32_t size, uint32_t align, RegIndex rm)
    : VldMultOp("vldmult", machInst, IntAluOp, width,
                     rn, vd, regs, inc, size, align, rm)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
        }
    }
}

VldSingle::VldSingle(ExtMachInst machInst, bool all, unsigned width,
        RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
        uint32_t size, uint32_t align, RegIndex rm, unsigned lane)
    : VldSingleOp("vldsingle", machInst, IntAluOp, all, width,
                     rn, vd, regs, inc, size, align, rm, lane)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
        }
    }
}

VstMult::VstMult(ExtMachInst machInst, unsigned width,
        RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
        uint32_t size, uint32_t align, RegIndex rm)
    : VstMultOp("vstmult", machInst, IntAluOp, width,
                     rn, vd, regs, inc, size, align, rm)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
        }
    }
}

VstSingle::VstSingle(ExtMachInst machInst, bool all, unsigned width,
        RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
        uint32_t size, uint32_t align, RegIndex rm, unsigned lane)
    : VstSingleOp("vstsingle", machInst, IntAluOp, all, width,
                     rn, vd, regs, inc, size, align, rm, lane)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
        }
    }
}

VLdmStm::VLdmStm(ExtMachInst machInst, IntRegIndex rn,
        RegIndex vd, bool single, bool up, bool writeback, bool load,
        uint32_t offset)
    : MacroVFPMemOp("vldmstm", machInst, IntAluOp, rn,
                     vd, single, up, writeback, load, offset)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
        }
    }
}


    AndImm::AndImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("and", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AndImmCc::AndImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("ands", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AndReg::AndReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("and", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AndRegCc::AndRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("ands", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AndRegReg::AndRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("and", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    AndRegRegCc::AndRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("ands", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    AndsImmPclr::AndsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("ands", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AndsRegPclr::AndsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("ands", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    EorImm::EorImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("eor", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    EorImmCc::EorImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("eors", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    EorReg::EorReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("eor", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    EorRegCc::EorRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("eors", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    EorRegReg::EorRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("eor", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    EorRegRegCc::EorRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("eors", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    EorsImmPclr::EorsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("eors", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    EorsRegPclr::EorsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("eors", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SubImm::SubImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("sub", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    SubImmCc::SubImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("subs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    SubReg::SubReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sub", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SubRegCc::SubRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("subs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SubRegReg::SubRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("sub", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SubRegRegCc::SubRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("subs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SubsImmPclr::SubsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("subs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    SubsRegPclr::SubsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("subs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    RsbImm::RsbImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("rsb", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    RsbImmCc::RsbImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("rsbs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    RsbReg::RsbReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("rsb", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    RsbRegCc::RsbRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("rsbs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    RsbRegReg::RsbRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("rsb", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    RsbRegRegCc::RsbRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("rsbs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    RsbsImmPclr::RsbsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("rsbs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    RsbsRegPclr::RsbsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("rsbs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AddImm::AddImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("add", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AddImmCc::AddImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adds", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AddReg::AddReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("add", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AddRegCc::AddRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("adds", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AddRegReg::AddRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("add", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    AddRegRegCc::AddRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("adds", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    AddsImmPclr::AddsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adds", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AddsRegPclr::AddsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("adds", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AdrImm::AdrImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adr", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AdrImmCc::AdrImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adrs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AdcImm::AdcImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adc", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AdcImmCc::AdcImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adcs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AdcReg::AdcReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("adc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AdcRegCc::AdcRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("adcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AdcRegReg::AdcRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("adc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    AdcRegRegCc::AdcRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("adcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    AdcsImmPclr::AdcsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adcs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    AdcsRegPclr::AdcsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("adcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SbcImm::SbcImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("sbc", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    SbcImmCc::SbcImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("sbcs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    SbcReg::SbcReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sbc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SbcRegCc::SbcRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sbcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SbcRegReg::SbcRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("sbc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SbcRegRegCc::SbcRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("sbcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SbcsImmPclr::SbcsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("sbcs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    SbcsRegPclr::SbcsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sbcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    RscImm::RscImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("rsc", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    RscImmCc::RscImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("rscs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    RscReg::RscReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("rsc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    RscRegCc::RscRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("rscs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    RscRegReg::RscRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("rsc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    RscRegRegCc::RscRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("rscs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    RscsImmPclr::RscsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("rscs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    RscsRegPclr::RscsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("rscs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    TstImm::TstImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("tst", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    TstImmCc::TstImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("tsts", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    TstReg::TstReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("tst", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    TstRegCc::TstRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("tsts", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    TstRegReg::TstRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("tst", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    TstRegRegCc::TstRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("tsts", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    TstsImmPclr::TstsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("tsts", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    TstsRegPclr::TstsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("tsts", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    TeqImm::TeqImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("teq", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    TeqImmCc::TeqImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("teqs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    TeqReg::TeqReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("teq", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    TeqRegCc::TeqRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("teqs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    TeqRegReg::TeqRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("teq", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    TeqRegRegCc::TeqRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("teqs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    TeqsImmPclr::TeqsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("teqs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    TeqsRegPclr::TeqsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("teqs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    CmpImm::CmpImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("cmp", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    CmpImmCc::CmpImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("cmps", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    CmpReg::CmpReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("cmp", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    CmpRegCc::CmpRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("cmps", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    CmpRegReg::CmpRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("cmp", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    CmpRegRegCc::CmpRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("cmps", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    CmpsImmPclr::CmpsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("cmps", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    CmpsRegPclr::CmpsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("cmps", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    CmnImm::CmnImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("cmn", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    CmnImmCc::CmnImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("cmns", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    CmnReg::CmnReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("cmn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    CmnRegCc::CmnRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("cmns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    CmnRegReg::CmnRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("cmn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    CmnRegRegCc::CmnRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("cmns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    CmnsImmPclr::CmnsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("cmns", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    CmnsRegPclr::CmnsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("cmns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    OrrImm::OrrImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("orr", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    OrrImmCc::OrrImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("orrs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    OrrReg::OrrReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("orr", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    OrrRegCc::OrrRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("orrs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    OrrRegReg::OrrRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("orr", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    OrrRegRegCc::OrrRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("orrs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    OrrsImmPclr::OrrsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("orrs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    OrrsRegPclr::OrrsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("orrs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    OrnImm::OrnImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("orn", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    OrnImmCc::OrnImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("orns", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    OrnReg::OrnReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("orn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    OrnRegCc::OrnRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("orns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    OrnRegReg::OrnRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("orn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    OrnRegRegCc::OrnRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("orns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    OrnsImmPclr::OrnsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("orns", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    OrnsRegPclr::OrnsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("orns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MovImm::MovImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("mov", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MovImmCc::MovImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("movs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MovReg::MovReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("mov", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (op2 == INTREG_LR) {
                flags[IsReturn] = true;
            }
        }

    }

    MovRegCc::MovRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("movs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (op2 == INTREG_LR) {
                flags[IsReturn] = true;
            }
        }

    }

    MovRegReg::MovRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("mov", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MovRegRegCc::MovRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("movs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MovsImmPclr::MovsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("movs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MovsRegPclr::MovsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("movs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    BicImm::BicImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("bic", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    BicImmCc::BicImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("bics", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    BicReg::BicReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("bic", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    BicRegCc::BicRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("bics", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    BicRegReg::BicRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("bic", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    BicRegRegCc::BicRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("bics", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    BicsImmPclr::BicsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("bics", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    BicsRegPclr::BicsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("bics", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MvnImm::MvnImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("mvn", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MvnImmCc::MvnImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("mvns", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MvnReg::MvnReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("mvn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MvnRegCc::MvnRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("mvns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MvnRegReg::MvnRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("mvn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MvnRegRegCc::MvnRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("mvns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MvnsImmPclr::MvnsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("mvns", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MvnsRegPclr::MvnsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("mvns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MovtImm::MovtImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("movt", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MovtImmCc::MovtImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("movts", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MovtReg::MovtReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("movt", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MovtRegCc::MovtRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("movts", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    MovtRegReg::MovtRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("movt", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MovtRegRegCc::MovtRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("movts", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MovtsImmPclr::MovtsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("movts", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    MovtsRegPclr::MovtsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("movts", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QaddRegCc::QaddRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qadds", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Qadd16Reg::Qadd16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qadd16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Qadd8Reg::Qadd8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qadd8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QdaddRegCc::QdaddRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qdadds", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QsubReg::QsubReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qsub", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QsubRegCc::QsubRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qsubs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Qsub16Reg::Qsub16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qsub16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Qsub8Reg::Qsub8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qsub8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QdsubRegCc::QdsubRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qdsubs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QasxReg::QasxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qasx", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    QsaxReg::QsaxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qsax", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Sadd8RegCc::Sadd8RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sadd8s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Sadd16RegCc::Sadd16RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sadd16s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Ssub8RegCc::Ssub8RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("ssub8s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Ssub16RegCc::Ssub16RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("ssub16s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SasxReg::SasxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sasx", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SasxRegCc::SasxRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sasxs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SsaxReg::SsaxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("ssax", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    SsaxRegCc::SsaxRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("ssaxs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Shadd8Reg::Shadd8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shadd8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Shadd16Reg::Shadd16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shadd16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Shsub8Reg::Shsub8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shsub8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Shsub16Reg::Shsub16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shsub16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    ShasxReg::ShasxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shasx", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    ShasxRegCc::ShasxRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shasxs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    ShsaxReg::ShsaxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shsax", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    ShsaxRegCc::ShsaxRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shsaxs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uqadd16Reg::Uqadd16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uqadd16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uqadd8Reg::Uqadd8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uqadd8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uqsub16Reg::Uqsub16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uqsub16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uqsub8Reg::Uqsub8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uqsub8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    UqasxReg::UqasxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uqasx", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    UqsaxReg::UqsaxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uqsax", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uadd16RegCc::Uadd16RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uadd16s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uadd8RegCc::Uadd8RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uadd8s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Usub16RegCc::Usub16RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("usub16s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Usub8RegCc::Usub8RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("usub8s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    UasxRegCc::UasxRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uasxs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    UsaxRegCc::UsaxRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("usaxs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_GE + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uhadd16Reg::Uhadd16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uhadd16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uhadd8Reg::Uhadd8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uhadd8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uhsub16Reg::Uhsub16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uhsub16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    Uhsub8Reg::Uhsub8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uhsub8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    UhasxReg::UhasxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uhasx", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    UhsaxReg::UhsaxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uhsax", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    PkhbtReg::PkhbtReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("pkhbt", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    PkhtbReg::PkhtbReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("pkhtb", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                 condCode == COND_CS || condCode == COND_CC ||
                 shiftType == ROR) ?
                CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    AdrXImm::AdrXImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("adr", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    AdrpXImm::AdrpXImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("adrp", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    AndXImm::AndXImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("and", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    AndXImmCc::AndXImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("ands", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    AndXSReg::AndXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("and", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    AndXSRegCc::AndXSRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("ands", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    AndXEReg::AndXEReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ArmExtendType _extendType,
                                          int32_t _shiftAmt)
        : DataXERegOp("and", machInst, IntAluOp,
                         _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    AndXERegCc::AndXERegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ArmExtendType _extendType,
                                          int32_t _shiftAmt)
        : DataXERegOp("ands", machInst, IntAluOp,
                         _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    EorXImm::EorXImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("eor", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    EorXSReg::EorXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("eor", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    EorXEReg::EorXEReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ArmExtendType _extendType,
                                          int32_t _shiftAmt)
        : DataXERegOp("eor", machInst, IntAluOp,
                         _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    EonXSReg::EonXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("eon", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    SubXImm::SubXImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("sub", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    SubXImmCc::SubXImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("subs", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    SubXSReg::SubXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("sub", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    SubXSRegCc::SubXSRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("subs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    SubXEReg::SubXEReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ArmExtendType _extendType,
                                          int32_t _shiftAmt)
        : DataXERegOp("sub", machInst, IntAluOp,
                         _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    SubXERegCc::SubXERegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ArmExtendType _extendType,
                                          int32_t _shiftAmt)
        : DataXERegOp("subs", machInst, IntAluOp,
                         _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    AddXImm::AddXImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("add", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    AddXImmCc::AddXImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("adds", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    AddXSReg::AddXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("add", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    AddXSRegCc::AddXSRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("adds", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    AddXEReg::AddXEReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ArmExtendType _extendType,
                                          int32_t _shiftAmt)
        : DataXERegOp("add", machInst, IntAluOp,
                         _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    AddXERegCc::AddXERegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ArmExtendType _extendType,
                                          int32_t _shiftAmt)
        : DataXERegOp("adds", machInst, IntAluOp,
                         _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    AdcXSReg::AdcXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("adc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	flags[IsInteger] = true;;
    }

    AdcXSRegCc::AdcXSRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("adcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    SbcXSReg::SbcXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("sbc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	flags[IsInteger] = true;;
    }

    SbcXSRegCc::SbcXSRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("sbcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    OrrXImm::OrrXImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("orr", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    OrrXSReg::OrrXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("orr", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    OrrXEReg::OrrXEReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ArmExtendType _extendType,
                                          int32_t _shiftAmt)
        : DataXERegOp("orr", machInst, IntAluOp,
                         _dest, _op1, _op2, _extendType, _shiftAmt)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    OrnXSReg::OrnXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("orn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    BicXSReg::BicXSReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("bic", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    BicXSRegCc::BicXSRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataXSRegOp("bics", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    Madd64::Madd64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3)
        : DataX3RegOp("madd", machInst, IntMultOp,
                         _dest, _op1, _op2, _op3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op3;
	flags[IsInteger] = true;;
    }

    Msub64::Msub64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3)
        : DataX3RegOp("msub", machInst, IntMultOp,
                         _dest, _op1, _op2, _op3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op3;
	flags[IsInteger] = true;;
    }

    Smaddl64::Smaddl64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3)
        : DataX3RegOp("smaddl", machInst, IntMultOp,
                         _dest, _op1, _op2, _op3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op3;
	flags[IsInteger] = true;;
    }

    Smsubl64::Smsubl64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3)
        : DataX3RegOp("smsubl", machInst, IntMultOp,
                         _dest, _op1, _op2, _op3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op3;
	flags[IsInteger] = true;;
    }

    Smulh64::Smulh64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : DataX2RegOp("smulh", machInst, IntMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Umaddl64::Umaddl64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3)
        : DataX3RegOp("umaddl", machInst, IntMultOp,
                         _dest, _op1, _op2, _op3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op3;
	flags[IsInteger] = true;;
    }

    Umsubl64::Umsubl64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3)
        : DataX3RegOp("umsubl", machInst, IntMultOp,
                         _dest, _op1, _op2, _op3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op3;
	flags[IsInteger] = true;;
    }

    Umulh64::Umulh64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : DataX2RegOp("umulh", machInst, IntMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Asrv64::Asrv64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : DataX2RegOp("asrv", machInst, IntAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
    }

    Lslv64::Lslv64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : DataX2RegOp("lslv", machInst, IntAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
    }

    Lsrv64::Lsrv64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : DataX2RegOp("lsrv", machInst, IntAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
    }

    Rorv64::Rorv64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : DataX2RegOp("rorv", machInst, IntAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
    }

    Sdiv64::Sdiv64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : DataX2RegOp("sdiv", machInst, IntDivOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Udiv64::Udiv64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : DataX2RegOp("udiv", machInst, IntDivOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    Cls64::Cls64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1)
        : DataX1RegOp("cls", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Clz64::Clz64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1)
        : DataX1RegOp("clz", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    Rbit64::Rbit64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1)
        : DataX1RegOp("rbit", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Rev64::Rev64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1)
        : DataX1RegOp("rev", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    Rev1664::Rev1664(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1)
        : DataX1RegOp("rev16", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Rev3264::Rev3264(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1)
        : DataX1RegOp("rev32", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Mrs64::Mrs64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("mrs", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPTR_EL2 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR_EL2 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPTR_EL3 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1 + Misc_Reg_Base;
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
    }

    MrsNZCV64::MrsNZCV64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1)
        : DataX1RegOp("mrsNZCV", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
    }

    Msr64::Msr64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("msr", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPTR_EL2 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR_EL2 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPTR_EL3 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

    MsrNZCV64::MsrNZCV64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1)
        : DataX1RegOp("msrNZCV", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
    }

    Dczva::Dczva(ExtMachInst machInst, IntRegIndex _base, IntRegIndex _dest, uint64_t _imm)
         : SysDC64("dczva", machInst, MemWriteOp,
                 (IntRegIndex)_base, _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPTR_EL2 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR_EL2 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPTR_EL3 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_DCZID_EL0 + Misc_Reg_Base;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        assert(!0);
    }

    MsrSP64::MsrSP64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("msrSP", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

    MsrDAIFSet64::MsrDAIFSet64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("msrDAIFSet", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

    MsrDAIFClr64::MsrDAIFClr64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm)
        : DataXImmOp("msrDAIFClr", machInst, IntAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR_EL3 + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
    }

    CcmnImm64::CcmnImm64(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          ConditionCode _condCode,
                                          uint8_t _defCc)
        : DataXCondCompImmOp("ccmn", machInst, IntAluOp,
                         _op1, _imm, _condCode, _defCc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    CcmpImm64::CcmpImm64(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          ConditionCode _condCode,
                                          uint8_t _defCc)
        : DataXCondCompImmOp("ccmp", machInst, IntAluOp,
                         _op1, _imm, _condCode, _defCc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    CcmnReg64::CcmnReg64(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode,
                                          uint8_t _defCc)
        : DataXCondCompRegOp("ccmn", machInst, IntAluOp,
                         _op1, _op2, _condCode, _defCc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    CcmpReg64::CcmpReg64(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode,
                                          uint8_t _defCc)
        : DataXCondCompRegOp("ccmp", machInst, IntAluOp,
                         _op1, _op2, _condCode, _defCc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
    }

    Csel64::Csel64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode)
        : DataXCondSelOp("csel", machInst, IntAluOp,
                         _dest, _op1, _op2, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
    }

    Csinc64::Csinc64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode)
        : DataXCondSelOp("csinc", machInst, IntAluOp,
                         _dest, _op1, _op2, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
    }

    Csinv64::Csinv64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode)
        : DataXCondSelOp("csinv", machInst, IntAluOp,
                         _dest, _op1, _op2, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
    }

    Csneg64::Csneg64(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode)
        : DataXCondSelOp("csneg", machInst, IntAluOp,
                         _dest, _op1, _op2, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
    }

    B::B(ExtMachInst machInst,
                                          int32_t _imm,
                                          ConditionCode _condCode)
        : BranchImmCond("b", machInst, IntAluOp,
                         _imm, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }


    ArmISA::PCState
    B::branchTarget(const ArmISA::PCState &branchPC) const
    {
        ;
        ;

        ArmISA::PCState pcs = branchPC;
        pcs.instNPC((uint32_t)(branchPC.instPC() + imm));
        pcs.advance();
        return pcs;
    }

    Bl::Bl(ExtMachInst machInst,
                                          int32_t _imm,
                                          ConditionCode _condCode)
        : BranchImmCond("bl", machInst, IntAluOp,
                         _imm, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_LR;
	_numIntDestRegs++;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }


    ArmISA::PCState
    Bl::branchTarget(const ArmISA::PCState &branchPC) const
    {
        ;
        ;

        ArmISA::PCState pcs = branchPC;
        pcs.instNPC((uint32_t)(branchPC.instPC() + imm));
        pcs.advance();
        return pcs;
    }

    BlxImm::BlxImm(ExtMachInst machInst,
                                          int32_t _imm,
                                          ConditionCode _condCode)
        : BranchImmCond("blx", machInst, IntAluOp,
                         _imm, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_LR;
	_numIntDestRegs++;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }


    ArmISA::PCState
    BlxImm::branchTarget(const ArmISA::PCState &branchPC) const
    {
        ;
        ;

        ArmISA::PCState pcs = branchPC;
        pcs.nextThumb(!branchPC.thumb());

            pcs.instNPC((uint32_t)(branchPC.thumb() ? (roundDown(branchPC.instPC(),4) + imm) :
                                (branchPC.instPC() + imm)));
            
        pcs.advance();
        return pcs;
    }

    BlxReg::BlxReg(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          ConditionCode _condCode)
        : BranchRegCond("blx", machInst, IntAluOp,
                         _op1, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_LR;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
        if (0)
            flags[IsReturn] = true;
    }

    BxReg::BxReg(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          ConditionCode _condCode)
        : BranchRegCond("bx", machInst, IntAluOp,
                         _op1, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
        if (op1 == INTREG_LR)
            flags[IsReturn] = true;
    }

    BxjReg::BxjReg(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          ConditionCode _condCode)
        : BranchRegCond("bxj", machInst, IntAluOp,
                         _op1, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HSTR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
        if (op1 == INTREG_LR)
            flags[IsReturn] = true;
    }

    Cbz::Cbz(ExtMachInst machInst,
                                          int32_t _imm,
                                          IntRegIndex _op1)
        : BranchImmReg("cbz", machInst, IntAluOp, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        flags[IsCondControl] = true;
    }


    ArmISA::PCState
    Cbz::branchTarget(const ArmISA::PCState &branchPC) const
    {
        ;
        ;

        ArmISA::PCState pcs = branchPC;
        pcs.instNPC((uint32_t)(branchPC.instPC() + imm));
        pcs.advance();
        return pcs;
    }

    Cbnz::Cbnz(ExtMachInst machInst,
                                          int32_t _imm,
                                          IntRegIndex _op1)
        : BranchImmReg("cbnz", machInst, IntAluOp, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        flags[IsCondControl] = true;
    }


    ArmISA::PCState
    Cbnz::branchTarget(const ArmISA::PCState &branchPC) const
    {
        ;
        ;

        ArmISA::PCState pcs = branchPC;
        pcs.instNPC((uint32_t)(branchPC.instPC() + imm));
        pcs.advance();
        return pcs;
    }

    Tbb::Tbb(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : BranchRegReg("tbb", machInst, MemReadOp, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }

    Tbh::Tbh(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : BranchRegReg("tbh", machInst, MemReadOp, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }

    B64::B64(ExtMachInst machInst,
                                          int64_t _imm)
        : BranchImm64("b", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsUncondControl] = true;;
    }

    Bl64::Bl64(ExtMachInst machInst,
                                          int64_t _imm)
        : BranchImm64("bl", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = INTREG_X30;
	_numIntDestRegs++;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    Br64::Br64(ExtMachInst machInst,
                                          IntRegIndex _op1)
        : BranchReg64("br", machInst, IntAluOp, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    Blr64::Blr64(ExtMachInst machInst,
                                          IntRegIndex _op1)
        : BranchReg64("blr", machInst, IntAluOp, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_X30;
	_numIntDestRegs++;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsUncondControl] = true;;
    }

    BCond64::BCond64(ExtMachInst machInst,
                                          int64_t _imm,
                                          ConditionCode _condCode)
        : BranchImmCond64("b", machInst, IntAluOp,
                         _imm, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;;
    }

    Ret64::Ret64(ExtMachInst machInst,
                                          IntRegIndex _op1)
        : BranchRet64("ret", machInst, IntAluOp, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsReturn] = true;
	flags[IsUncondControl] = true;;
    }

        Eret64::Eret64(ExtMachInst machInst)  : BranchEret64("eret", machInst, IntAluOp)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_LOCKFLAG + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        }

    Cbz64::Cbz64(ExtMachInst machInst,
                                          int64_t _imm,
                                          IntRegIndex _op1)
        : BranchImmReg64("cbz", machInst, IntAluOp, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

    Cbnz64::Cbnz64(ExtMachInst machInst,
                                          int64_t _imm,
                                          IntRegIndex _op1)
        : BranchImmReg64("cbnz", machInst, IntAluOp, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

    Tbz64::Tbz64(ExtMachInst machInst,
                                          int64_t _imm1, int64_t _imm2,
                                          IntRegIndex _op1)
        : BranchImmImmReg64("tbz", machInst, IntAluOp,
                         _imm1, _imm2, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

    Tbnz64::Tbnz64(ExtMachInst machInst,
                                          int64_t _imm1, int64_t _imm2,
                                          IntRegIndex _op1)
        : BranchImmImmReg64("tbnz", machInst, IntAluOp,
                         _imm1, _imm2, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
    }

    Mla::Mla(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("mla", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MlaCc::MlaCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("mlas", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Mls::Mls(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("mls", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Mul::Mul(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("mul", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MulCc::MulCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("muls", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmlabbCc::SmlabbCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlabbs", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmlabtCc::SmlabtCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlabts", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmlatbCc::SmlatbCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlatbs", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmlattCc::SmlattCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlatts", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmladCc::SmladCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlads", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmladxCc::SmladxCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smladxs", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smlal::Smlal(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlal", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmlalCc::SmlalCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlals", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smlalbb::Smlalbb(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlalbb", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smlalbt::Smlalbt(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlalbt", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smlaltb::Smlaltb(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlaltb", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smlaltt::Smlaltt(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlaltt", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smlald::Smlald(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlald", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smlaldx::Smlaldx(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlaldx", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmlawbCc::SmlawbCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlawbs", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmlawtCc::SmlawtCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlawts", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmlsdCc::SmlsdCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlsds", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmlsdxCc::SmlsdxCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlsdxs", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smlsld::Smlsld(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlsld", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smlsldx::Smlsldx(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlsldx", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smmla::Smmla(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smmla", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smmlar::Smmlar(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smmlar", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smmls::Smmls(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smmls", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smmlsr::Smmlsr(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smmlsr", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smmul::Smmul(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smmul", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smmulr::Smmulr(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smmulr", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmuadCc::SmuadCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smuads", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmuadxCc::SmuadxCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smuadxs", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smulbb::Smulbb(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smulbb", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smulbt::Smulbt(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smulbt", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smultb::Smultb(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smultb", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smultt::Smultt(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smultt", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smull::Smull(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smull", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    SmullCc::SmullCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smulls", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smulwb::Smulwb(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smulwb", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smulwt::Smulwt(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smulwt", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smusd::Smusd(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smusd", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Smusdx::Smusdx(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smusdx", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Umaal::Umaal(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("umaal", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Umlal::Umlal(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("umlal", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    UmlalCc::UmlalCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("umlals", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Umull::Umull(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("umull", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    UmullCc::UmullCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("umulls", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Sdiv::Sdiv(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("sdiv", machInst, IntDivOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Udiv::Udiv(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("udiv", machInst, IntDivOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Vmsr::Vmsr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmsr", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmsrFpscr::VmsrFpscr(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmsr", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Vmrs::Vmrs(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmrs", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_HCR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1 + Misc_Reg_Base;
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmrsFpscr::VmrsFpscr(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmrs", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_FP + CC_Reg_Base;
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        VmrsApsrFpscr::VmrsApsrFpscr(ExtMachInst machInst)  : PredOp("vmrs", machInst, SimdFloatMiscOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_FP + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    VmovImmS::VmovImmS(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovImmD::VmovImmD(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovImmQ::VmovImmQ(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovRegS::VmovRegS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovRegD::VmovRegD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovRegQ::VmovRegQ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovCoreRegB::VmovCoreRegB(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovCoreRegH::VmovCoreRegH(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovCoreRegW::VmovCoreRegW(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovRegCoreUB::VmovRegCoreUB(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovRegCoreUH::VmovRegCoreUH(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovRegCoreSB::VmovRegCoreSB(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovRegCoreSH::VmovRegCoreSH(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmovRegCoreW::VmovRegCoreW(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Vmov2Reg2Core::Vmov2Reg2Core(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    Vmov2Core2Reg::Vmov2Core2Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = op1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VfmaS::VfmaS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfmas", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VfmaD::VfmaD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfmad", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VfmsS::VfmsS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfmss", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VfmsD::VfmsD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfmsd", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VfnmaS::VfnmaS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfnmas", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VfnmaD::VfnmaD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfnmad", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VfnmsS::VfnmsS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfnmss", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VfnmsD::VfnmsD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vfnmsd", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VaddS::VaddS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vadds", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VaddD::VaddD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vaddd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VsubS::VsubS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vsubs", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VsubD::VsubD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vsubd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VdivS::VdivS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vdivs", machInst, SimdFloatDivOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VdivD::VdivD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vdivd", machInst, SimdFloatDivOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmulS::VmulS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmuls", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmulD::VmulD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmuld", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VsqrtS::VsqrtS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vsqrts", machInst, SimdFloatSqrtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VsqrtD::VsqrtD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vsqrtd", machInst, SimdFloatSqrtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VnegS::VnegS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vnegs", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VnegD::VnegD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vnegd", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VabsS::VabsS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vabss", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VabsD::VabsD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vabsd", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VRIntPS::VRIntPS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vrintps", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VRIntPD::VRIntPD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vrintpd", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VRIntMS::VRIntMS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vrintms", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VRIntMD::VRIntMD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vrintmd", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VRIntAS::VRIntAS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vrintas", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VRIntAD::VRIntAD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vrintad", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VRIntNS::VRIntNS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vrintns", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VRIntND::VRIntND(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vrintnd", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmlaS::VmlaS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmlas", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmlaD::VmlaD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmlad", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmlsS::VmlsS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmlss", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VmlsD::VmlsD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmlsd", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VnmlaS::VnmlaS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmlas", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VnmlaD::VnmlaD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmlad", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VnmlsS::VnmlsS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmlss", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VnmlsD::VnmlsD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmlsd", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VnmulS::VnmulS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmuls", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VnmulD::VnmulD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmuld", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtUIntFpS::VcvtUIntFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtUIntFpD::VcvtUIntFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtSIntFpS::VcvtSIntFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtSIntFpD::VcvtSIntFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpUIntSR::VcvtFpUIntSR(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpUIntDR::VcvtFpUIntDR(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtr", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSIntSR::VcvtFpSIntSR(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtr", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSIntDR::VcvtFpSIntDR(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtr", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpUIntS::VcvtFpUIntS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpUIntD::VcvtFpUIntD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSIntS::VcvtFpSIntS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSIntD::VcvtFpSIntD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSFpD::VcvtFpSFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpDFpS::VcvtFpDFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpHTFpS::VcvtFpHTFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpHBFpS::VcvtFpHBFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtb", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSFpHT::VcvtFpSFpHT(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSFpHB::VcvtFpSFpHB(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtb", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcmpS::VcmpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcmps", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcmpD::VcmpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcmpd", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcmpZeroS::VcmpZeroS(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vcmpZeros", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcmpZeroD::VcmpZeroD(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vcmpZerod", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcmpeS::VcmpeS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcmpes", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcmpeD::VcmpeD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcmped", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcmpeZeroS::VcmpeZeroS(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vcmpeZeros", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcmpeZeroD::VcmpeZeroD(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vcmpeZerod", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VselS::VselS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _cond,
                                          VfpMicroMode mode)
        : FpRegRegRegCondOp("vsels", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2, _cond, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
    }

    VselD::VselD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _cond,
                                          VfpMicroMode mode)
        : FpRegRegRegCondOp("vseld", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2, _cond, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	flags[IsFloating] = true;;
    }

    VcvtFpSFixedS::VcvtFpSFixedS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSFixedD::VcvtFpSFixedD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpUFixedS::VcvtFpUFixedS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpUFixedD::VcvtFpUFixedD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtSFixedFpS::VcvtSFixedFpS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtSFixedFpD::VcvtSFixedFpD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtUFixedFpS::VcvtUFixedFpS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtUFixedFpD::VcvtUFixedFpD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSHFixedS::VcvtFpSHFixedS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpSHFixedD::VcvtFpSHFixedD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpUHFixedS::VcvtFpUHFixedS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtFpUHFixedD::VcvtFpUHFixedD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtSHFixedFpS::VcvtSHFixedFpS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtSHFixedFpD::VcvtSHFixedFpD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtUHFixedFpS::VcvtUHFixedFpS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    VcvtUHFixedFpD::VcvtUHFixedFpD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FmovImmS::FmovImmS(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("fmov", machInst, FloatMiscOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FmovImmD::FmovImmD(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("fmov", machInst, FloatMiscOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FmovRegS::FmovRegS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fmov", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FmovRegD::FmovRegD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fmov", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FmovCoreRegW::FmovCoreRegW(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fmov", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FmovCoreRegX::FmovCoreRegX(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fmov", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FmovUCoreRegX::FmovUCoreRegX(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fmov", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FmovRegCoreW::FmovRegCoreW(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fmov", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FmovRegCoreX::FmovRegCoreX(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fmov", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FmovURegCoreX::FmovURegCoreX(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fmov", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 2) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FMAddD::FMAddD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3,
                                          VfpMicroMode mode)
        : FpRegRegRegRegOp("fmadd", machInst, FloatMultAccOp,
                         _dest, _op1, _op2, _op3, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMAddS::FMAddS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3,
                                          VfpMicroMode mode)
        : FpRegRegRegRegOp("fmadd", machInst, FloatMultAccOp,
                         _dest, _op1, _op2, _op3, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMSubD::FMSubD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3,
                                          VfpMicroMode mode)
        : FpRegRegRegRegOp("fmsub", machInst, FloatMultAccOp,
                         _dest, _op1, _op2, _op3, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMSubS::FMSubS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3,
                                          VfpMicroMode mode)
        : FpRegRegRegRegOp("fmsub", machInst, FloatMultAccOp,
                         _dest, _op1, _op2, _op3, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FNMAddD::FNMAddD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3,
                                          VfpMicroMode mode)
        : FpRegRegRegRegOp("fnmadd", machInst, FloatMultAccOp,
                         _dest, _op1, _op2, _op3, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FNMAddS::FNMAddS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3,
                                          VfpMicroMode mode)
        : FpRegRegRegRegOp("fnmadd", machInst, FloatMultAccOp,
                         _dest, _op1, _op2, _op3, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FNMSubD::FNMSubD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3,
                                          VfpMicroMode mode)
        : FpRegRegRegRegOp("fnmsub", machInst, FloatMultAccOp,
                         _dest, _op1, _op2, _op3, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FNMSubS::FNMSubS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3,
                                          VfpMicroMode mode)
        : FpRegRegRegRegOp("fnmsub", machInst, FloatMultAccOp,
                         _dest, _op1, _op2, _op3, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op3 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FAddS::FAddS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fadd", machInst, FloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FAddD::FAddD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fadd", machInst, FloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FSubS::FSubS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fsub", machInst, FloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FSubD::FSubD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fsub", machInst, FloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FDivS::FDivS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fdiv", machInst, FloatDivOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FDivD::FDivD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fdiv", machInst, FloatDivOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMulS::FMulS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fmul", machInst, FloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMulD::FMulD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fmul", machInst, FloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FNMulS::FNMulS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fnmul", machInst, FloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FNMulD::FNMulD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fnmul", machInst, FloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMinS::FMinS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fmin", machInst, FloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMinD::FMinD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fmin", machInst, FloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMaxS::FMaxS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fmax", machInst, FloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMaxD::FMaxD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fmax", machInst, FloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMinNMS::FMinNMS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fminnm", machInst, FloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMinNMD::FMinNMD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fminnm", machInst, FloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMaxNMS::FMaxNMS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fmaxnm", machInst, FloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FMaxNMD::FMaxNMD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("fmaxnm", machInst, FloatCmpOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FSqrtS::FSqrtS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fsqrt", machInst, FloatSqrtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FSqrtD::FSqrtD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fsqrt", machInst, FloatSqrtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FNegS::FNegS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fneg", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FNegD::FNegD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fneg", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FAbsS::FAbsS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fabs", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FAbsD::FAbsD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fabs", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntNS::FRIntNS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintn", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntND::FRIntND(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintn", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntPS::FRIntPS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintp", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntPD::FRIntPD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintp", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntMS::FRIntMS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintm", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntMD::FRIntMD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintm", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntZS::FRIntZS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintz", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntZD::FRIntZD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintz", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntAS::FRIntAS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frinta", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntAD::FRIntAD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frinta", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntIS::FRIntIS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frinti", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntID::FRIntID(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frinti", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntXS::FRIntXS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintx", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FRIntXD::FRIntXD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("frintx", machInst, FloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FcvtWUIntFpD::FcvtWUIntFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("ucvtf", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtWSIntFpD::FcvtWSIntFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("scvtf", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtWUIntFpS::FcvtWUIntFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("ucvtf", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtWSIntFpS::FcvtWSIntFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("scvtf", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtXUIntFpD::FcvtXUIntFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("ucvtf", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtXSIntFpD::FcvtXSIntFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("scvtf", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtXUIntFpS::FcvtXUIntFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("ucvtf", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtXSIntFpS::FcvtXSIntFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("scvtf", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtFpSIntXDN::FcvtFpSIntXDN(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntXDP::FcvtFpSIntXDP(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntXDM::FcvtFpSIntXDM(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntXDZ::FcvtFpSIntXDZ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntXDA::FcvtFpSIntXDA(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWDN::FcvtFpSIntWDN(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWDP::FcvtFpSIntWDP(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWDM::FcvtFpSIntWDM(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWDZ::FcvtFpSIntWDZ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWDA::FcvtFpSIntWDA(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXDN::FcvtFpUIntXDN(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXDP::FcvtFpUIntXDP(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXDM::FcvtFpUIntXDM(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXDZ::FcvtFpUIntXDZ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXDA::FcvtFpUIntXDA(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWDN::FcvtFpUIntWDN(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWDP::FcvtFpUIntWDP(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWDM::FcvtFpUIntWDM(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWDZ::FcvtFpUIntWDZ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWDA::FcvtFpUIntWDA(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntXSN::FcvtFpSIntXSN(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntXSP::FcvtFpSIntXSP(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntXSM::FcvtFpSIntXSM(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntXSZ::FcvtFpSIntXSZ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntXSA::FcvtFpSIntXSA(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWSN::FcvtFpSIntWSN(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWSP::FcvtFpSIntWSP(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWSM::FcvtFpSIntWSM(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWSZ::FcvtFpSIntWSZ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSIntWSA::FcvtFpSIntWSA(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAs", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXSN::FcvtFpUIntXSN(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXSP::FcvtFpUIntXSP(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXSM::FcvtFpUIntXSM(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXSZ::FcvtFpUIntXSZ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntXSA::FcvtFpUIntXSA(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWSN::FcvtFpUIntWSN(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtNu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWSP::FcvtFpUIntWSP(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtPu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWSM::FcvtFpUIntWSM(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtMu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWSZ::FcvtFpUIntWSZ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtZu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUIntWSA::FcvtFpUIntWSA(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvtAu", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FCvtFpSFpD::FCvtFpSFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvt", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FcvtFpDFpS::FcvtFpDFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvt", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FcvtFpHFpD::FcvtFpHFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvt", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FcvtFpHFpS::FcvtFpHFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvt", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FcvtFpDFpH::FcvtFpDFpH(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvt", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FcvtFpSFpH::FcvtFpSFpH(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcvt", machInst, FloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FCmpImmD::FCmpImmD(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("fcmp", machInst, FloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCmpRegD::FCmpRegD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcmp", machInst, FloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCmpImmS::FCmpImmS(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("fcmp", machInst, FloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCmpRegS::FCmpRegS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcmp", machInst, FloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCmpEImmD::FCmpEImmD(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("fcmpe", machInst, FloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCmpERegD::FCmpERegD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcmpe", machInst, FloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCmpEImmS::FCmpEImmS(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("fcmpe", machInst, FloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCmpERegS::FCmpERegS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("fcmpe", machInst, FloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCCmpRegD::FCCmpRegD(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode,
                                          uint8_t _defCc)
        : FpCondCompRegOp("fccmp", machInst, FloatCmpOp,
                         _op1, _op2, _condCode, _defCc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCCmpRegS::FCCmpRegS(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode,
                                          uint8_t _defCc)
        : FpCondCompRegOp("fccmp", machInst, FloatCmpOp,
                         _op1, _op2, _condCode, _defCc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCCmpERegD::FCCmpERegD(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode,
                                          uint8_t _defCc)
        : FpCondCompRegOp("fccmpe", machInst, FloatCmpOp,
                         _op1, _op2, _condCode, _defCc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FCCmpERegS::FCCmpERegS(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode,
                                          uint8_t _defCc)
        : FpCondCompRegOp("fccmpe", machInst, FloatCmpOp,
                         _op1, _op2, _condCode, _defCc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_NZ + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_C + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_V + CC_Reg_Base;
	_numCCDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = CCREG_FP + CC_Reg_Base;
	_numCCDestRegs++;
	flags[IsFloating] = true;;
    }

    FcvtFpSFixedDX::FcvtFpSFixedDX(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("fcvtzs", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtSFixedFpDX::FcvtSFixedFpDX(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("scvtf", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUFixedDX::FcvtFpUFixedDX(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("fcvtzu", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtUFixedFpDX::FcvtUFixedFpDX(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("ucvtf", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSFixedSX::FcvtFpSFixedSX(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("fcvtzs", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtSFixedFpSX::FcvtSFixedFpSX(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("scvtf", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUFixedSX::FcvtFpUFixedSX(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("fcvtzu", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtUFixedFpSX::FcvtUFixedFpSX(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("ucvtf", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSFixedDW::FcvtFpSFixedDW(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("fcvtzs", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtSFixedFpDW::FcvtSFixedFpDW(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("scvtf", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUFixedDW::FcvtFpUFixedDW(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("fcvtzu", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtUFixedFpDW::FcvtUFixedFpDW(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("ucvtf", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpSFixedSW::FcvtFpSFixedSW(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("fcvtzs", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtSFixedFpSW::FcvtSFixedFpSW(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("scvtf", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FcvtFpUFixedSW::FcvtFpUFixedSW(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("fcvtzu", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
    }

    FcvtUFixedFpSW::FcvtUFixedFpSW(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("ucvtf", machInst, FloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR_EL1 + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    FCSelD::FCSelD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode)
        : FpCondSelOp("fcsel", machInst, FloatCvtOp,
                         _dest, _op1, _op2, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    FCSelS::FCSelS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          ConditionCode _condCode)
        : FpCondSelOp("fcsel", machInst, FloatCvtOp,
                         _dest, _op1, _op2, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = CCREG_NZ + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_C + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = CCREG_V + CC_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = ((op1 * 4) + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((op2 * 4) + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = ((dest * 4) + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
    }

    NVtbl1::NVtbl1(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    NVtbl2::NVtbl2(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    NVtbl3::NVtbl3(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 4) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 5) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    NVtbl4::NVtbl4(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 4) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 5) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 6) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 7) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    NVtbx1::NVtbx1(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    NVtbx2::NVtbx2(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    NVtbx3::NVtbx3(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_AL || condCode == COND_UC ||
                 condCode == COND_CC || condCode == COND_CS ||
                 condCode == COND_VS || condCode == COND_VC) ?
                CCREG_ZERO : CCREG_NZ) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               CCREG_C : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ((condCode == COND_VS || condCode == COND_VC ||
                 condCode == COND_GE || condCode == COND_LT ||
                 condCode == COND_GT || condCode == COND_LE) ?
                CCREG_V : CCREG_ZERO) + CC_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_NSACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 4) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 5) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }